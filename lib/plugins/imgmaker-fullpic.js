const { anya } = require('../lib');

anya({
  name: [
    "fullpic"
  ],
  alias: [
    "fulpic",
    "fullpicture"
  ],
  category: "imgmaker",
  desc: "Convert any image ratio into 1:1 with white background.",
  filename: "/workspaces/Anya_v2-MD/test.js"
}, 
async (anyaV2, pika, prefix, command) => {
  const Config = require("../../config");
  const quoted = pika.quoted ? pika.quoted : pika;
  const mime = (quoted.msg || quoted).mimetype || "";
  if (!/image/.test(mime)) return pika.reply(`Please tag an image or send an image with caption *${prefix + command}*`);
  await pika.react("🤍");
  const util = require('util');
  const exec = util.promisify(require('child_process').exec);
  const fs = require('fs').promises;
  const path = require('path');
  const Jimp = require('jimp');
  const proceed = await anyaV2.sendMessage(pika.chat, { text: Config.message.wait }, { quoted: pika });
  const image = await quoted.download(await getRandomName(4));
  const mName = await getRandomName(5) + '.jpg';
  const pathOut = path.join(__dirname, '..', 'database', 'trash', mName);
 
  async function makeMedia(mediaBuffer, mName) {
  try {
    const image = await Jimp.read(mediaBuffer);
    if (image.getWidth() === image.getHeight()) return pika.edit("✅ This media is already in a square size.", proceed.key);
    const size = Math.max(image.getWidth(), image.getHeight());
    const squareImage = new Jimp(size, size, 0xFFFFFFFF);
    squareImage.composite(image, (size - image.getWidth()) / 2, (size - image.getHeight()) / 2);
    await squareImage.writeAsync(pathOut);
    pika.delete(proceed.key);
    return true;
  } catch (error) {
    pika.edit("❌ Can't proceed this media, please choose another.", proceed.key);
    return
  }
}

makeMedia(image, mName).then(async (result) => {
  if (result) {
    try {
      const media = await fs.readFile(pathOut);
      await anyaV2.sendMessage(pika.chat, {
        image: media,
        caption: `_© Generated by ${Config.botname}_`
      }, { quoted: pika });
      await fs.unlink(pathOut);
    } catch (error) {
      console.error('Error:', error);
    }
  }
});
});
